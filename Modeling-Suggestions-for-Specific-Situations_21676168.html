<!DOCTYPE html>
<html>
    <head>
        <title>Qeo Open Source Project Documentation : Modeling Suggestions for Specific Situations</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="docindex.html">Qeo Open Source Project Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Qeo-Open-Source-Project-Documentation_21675984.html">Qeo Open Source Project Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Developer-Documents_21676035.html">Developer Documents</a></span>
                            </li>
                                                    <li>
                                <span><a href="21676165.html">Qeo Data Model (QDM) Developer Guide</a></span>
                            </li>
                                                    <li>
                                <span><a href="Best-Practices_21676166.html">Best Practices</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Qeo Open Source Project Documentation : Modeling Suggestions for Specific Situations
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
    
            Created by <span class='author'> lissensj</span> on May 21, 2014
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h4 id="ModelingSuggestionsforSpecificSituations-SourcesofVariabilityinaDirectedStatePattern">Sources of Variability in a Directed State Pattern</h4><p>Although a Directed State pattern looks rather straightforward on paper,  there are an infinite number of variations in the way it can be modeled in practice. There is no single, <em>right</em> way to do it: a lot depends on the particular use case you are implementing.</p><p>The most common sources of variability in the eventual modeling are:</p><ul><li>Life cycle of the Desired State</li><li>Are State instances creatable or deletable on request?</li><li>Is the process of evolving a Current State towards the Desired State quick or slow?</li><li>Is there a need for error feedback?</li><li>Should the Requester know whether a state change was done on his behalf?</li><li>Does it make sense to initiate state changes that were requested based on an outdated view of the state?</li></ul><p>In this section, we discuss each of the aforementioned sources of modeling variability, and provide some suggestions on how to tackle specific situations.</p><h4 id="ModelingSuggestionsforSpecificSituations-LifeCycleoftheDesiredState">Life Cycle of the Desired State</h4><p>The Requester's Desired State is (as the name implies) conceptually a form of State. However, modeling it as such has certain implications on the structure and handling of the Desired State topic:</p><ul><li>Because State is exclusively owned by its publisher, the Desired State topic cannot have the exact same structure as the Current State topic. Rather, at least one extra field identifying the Requester should be added to the key of the data structure, otherwise it would become impossible for multiple Requesters to express a Desired State for the same instance concurrently (otherwise, both publications have the same key, and the exclusivity rules will consistently hide one in favor of the other).</li><li>Desired State instances have a life cycle that needs to be managed: at some point, the request is no longer relevant (either because it's fulfilled, or because the Requester lost interest and gave up). The Requester has to keep track of all extant Desired States it published, and must clean them up when they are not longer relevant.</li></ul><p>Therefore, in many cases it is pragmatic (though conceptually less clean) to represent the Desired State as Event rather than State. This makes publishing a Desired State a simple fire-and-forget operation. This has some semantic implications:</p><ul><li>Desired State samples arrive at the Effector as a sequential stream, suggesting they will be handled one-by-one in the order they come in.</li><li>Automatic conflict resolution: two Requesters that concurrently issue conflicting Desired States for a given instance will just appear as two consecutive requests to the Effector</li><li>No revocation: if Desired State is a State, it is possible to revoke an existing request by just disposing of the Desired State instance. The fire-and-forget nature of Events makes this impossible.</li><li>The Effector cannot be late: if the Effector is not yet active or subscribed to the Desired State topic, it will miss Desired State publications, and it will not be able to act upon them. Typically, this is not a problem, as the non-existence of the Effector means no Current State is published and hence there is nothing for which to specify Desired State. If Current State instances can be created upon request however, this equation changes: perhaps it makes sense to have the Requester publish the request to create a new instance without first having to check whether an Effector is already up and running.</li></ul><h4 id="ModelingSuggestionsforSpecificSituations-AreCurrentStateInstancesCreatable/DeletableonRequest">Are Current State Instances Creatable/Deletable on Request</h4><p>Requesters can only express their desire to change the state of <em>existing</em> Current State instances, not their desire for the creation or deletion of such instances.</p><p>Once creation and deletion come into play, a number of extra questions need to be answered:</p><ul><li>Are create and delete requests modeled on the same topic as the update (Desired State) requests?</li><li>Will Requesters have the need to specify explicitly which Effector should create the Current State instance (consider &quot;I want to create a firewall rule for that specific firewall&quot; versus &quot;I want to set up a phone call but I don't care who handles it for me&quot;)?</li></ul><p>To the extent possible, we advocate to use the existing Desired State topic to represent all requests (Create, Delete and Update). This is the most economical and clean way to model this. A good reason to deviate from this rule of thumb would be the differing life cycle of one type of request versus the other (maybe Create requests are State, whereas Update requests are Event?).</p><p>If the Create requests are undirected (i.e. any Effector may handle them), it is necessary to define some kind of protocol to handle the fact that multiple Effectors may step in to handle the request, resulting in the creation of multiple Current State instances instead of just the one that was needed. Some alternatives here:</p><ul><li>Let the Requester issue explicit Delete requests for each of the spuriously created instances</li><li>Let Effectors create the new instances in a kind of &quot;limbo&quot; state. The Requester sees many instances being created in response to its request, and picks the one it likes most (typically the first one). For this particular instance, it publishes a new Desired State to pull it out of the &quot;limbo&quot; state. All other Effectors observe the state change on the alternative instance, and conclude they can dispose of their &quot;limbo&quot; instances, as they are not chosen by the Requester.</li></ul><p>Whatever option one chooses, <em>this must be documented explicitly in the QDM file<strong>. </strong></em></p><h4 id="ModelingSuggestionsforSpecificSituations-IstheProcessofEvolvingCurrentStateTowardsDesiredStateQuickorSlow">Is the Process of Evolving Current State Towards Desired State Quick or Slow</h4><p>In case the actual evolution of Current State towards the desired end state takes a lot of time (dependent on a slow underlying physical process) or traverses through a lot of intermediate states, it may make sense for the Effector to advertise in which direction it is evolving the Current State, by publishing in addition a so-called <strong>Objective State</strong>. This allows the Effector to advertise to the world &quot;this is what I'm headed for&quot;. Requesters can then observe both the Current State and Objective State, and make informed decisions based on both.</p><p>The Objective State, just like the Current State, would be modeled with the State behavior. The structure of both types (including key fields) should be identical. It is advisable to publish an Objective State instance for each Current State instance &quot;owned&quot; by the Effector. This allows us to assign a meaning to discrepancies in the existence of instances on both topics:</p><ul><li>an instance exists as Current State but not as Objective State: it is en route to be destroyed.</li><li>an instance exists as Objective State but not as Current State: it is in the process of being created.</li></ul><h4 id="ModelingSuggestionsforSpecificSituations-IsThereaNeedforErrorFeedback">Is There a Need for Error Feedback</h4><p>In general, try to avoid interaction patterns with explicit &quot;return code&quot;-like behavior. They inevitably lead to RPC-like tightly-coupled interactions. However, in some cases it may be relevant for the Effector to supply error information based on the Desired State it observes. In that case, define a second topic (as an Event) where the error codes/situations/explanations can be advertised to the world.</p><h4 id="ModelingSuggestionsforSpecificSituations-ShouldtheRequesterKnowWhetheraStateChangeWasDoneOnhisBehalf">Should the Requester Know Whether a State Change Was Done On his Behalf</h4><p>When the Requester absolutely needs to know (again, something to avoid if possible) whether a given state change was the result of its own Desired State, you can model this as follows:</p><ol><li>Put a unique id in the Desired State</li><li>Put a field &quot;inResponseTo&quot; in the Current State, which replicates the unique id from the Desired State that triggered the Current State to move to its current level.</li></ol><h4 id="ModelingSuggestionsforSpecificSituations-DoesItMakeSensetoInitiateStateChangesthatWereRequestedBasedonanOutdatedViewoftheState">Does It Make Sense to Initiate State Changes that Were Requested Based on an Outdated View of the State</h4><p>In some cases, it does not make sense to express a Desired State based on an outdated view of the Current State. Imagine a situation where there is one Effector and two Requesters (A and B). Both requesters observe Current State S0, and concurrently decide to publish a Desired State S0<sub>A</sub> (by A) and S0<sub>B</sub> (by B). These decisions make sense <em>in the context of Current State S0</em>. The Effector sees A's desired state first, and as a consequence it evolves the Current State towards S1 (not necessarily equal to S0<sub>A</sub>). In the context of S1, Requester B's decision to publish a Desired State S0<sub>B</sub> is no longer valid, but there is a time window in which the Effector will see Desired State S0<sub>B</sub> while Requester B still has not noticed Current State S1, and hence has not yet updated its Desired State to the new correct value S1<sub>B</sub>.</p><p>One may avoid this kind of situation by adding a discrete time stamp to the data model, with the following semantics:</p><ul><li>The time stamp is an integer counter added to the Current State</li><li>Each new value of an instance on the Current State increments the counter</li><li>Desired State incorporates an &quot;in-the-context-of&quot; field that holds the value of the timestamp counter of the Current State value from which this Desired State was inferred.</li><li>The Effector ignores each Desired State value that has an &quot;in-the-context-of&quot; field that is out of date with respect to the current timestamp of the affected instance.</li></ul>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer">
                <section class="footer-body">
                    <p>Document generated by Confluence on May 26, 2014 09:36</p>
                </section>
            </div>
        </div>     </body>
</html>
